[{"authors":["admin"],"categories":null,"content":"I am Kirshanthan (\u0026ldquo;Krish\u0026rdquo;) Sundararajah. I am a Ph.D. candidate at the School of Electrical and Computer Engineering, Purdue University.\nMy research interests span the areas of compilers, programming language, and high performance computing. I am particularly interested in solving performance challenges in irregular programs. I have recently focused on theorizing the correctness of scheduling transformations for general recursive programs as a means to bring performance transparent abstractions to compilers.\nMy adviser is Milind Kulkarni. I have earned my bachelor\u0026rsquo;s in electronic and telecommunication engineering from University of Moratuwa.\nI am in the academic job market! Please feel free to reach out\n[Academic CV] [Research Statement] [Teaching Statement]\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://kirshanthans.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"I am Kirshanthan (\u0026ldquo;Krish\u0026rdquo;) Sundararajah. I am a Ph.D. candidate at the School of Electrical and Computer Engineering, Purdue University.\nMy research interests span the areas of compilers, programming language, and high performance computing. I am particularly interested in solving performance challenges in irregular programs. I have recently focused on theorizing the correctness of scheduling transformations for general recursive programs as a means to bring performance transparent abstractions to compilers.","tags":null,"title":"","type":"authors"},{"authors":["Charitha Saumya","Kirshanthan Sundararajah","Milind Kulkarni"],"categories":null,"content":"","date":1640995200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1640995200,"objectID":"6c11f4c0a0a1e5beade846e743068f49","permalink":"https://kirshanthans.github.io/publication/cgo2022/","publishdate":"2022-01-01T00:00:00Z","relpermalink":"/publication/cgo2022/","section":"publication","summary":"GPGPUs use the Single-Instruction-Multiple-Thread (SIMT) execution model where a group of threads--wavefront or war--execute instructions in lockstep. When threads in a group encounter a branching instruction, not all threads in the group take the same path, a phenomenon known as control-flow divergence. The control-flow divergence causes performance degradation because both paths of the branch must be executed one after the other. Prior research has primarily addressed this issue through architectural modifications. We observe that certain GPGPU kernels with control-flow divergence have similar control-flow structures with similar instructions on both sides of a branch. This structure can be exploited to reduce control-flow divergence by melding the two sides of the branch allowing threads to reconverge early, reducing divergence. In this work, we present CFM, a compiler analysis and transformation framework that can meld divergent control-flow structures with similar instruction sequences. We show that CFM can reduce the performance degradation from control-flow divergence.","tags":[],"title":"DARM: Control-Flow Melding for SIMT Thread Divergence Reduction","type":"publication"},{"authors":["Yuyan Bao","Kirshanthan Sundararajah","Raghav Malik","Qianchuan Ye","Christopher Wagner","Nouraldin Jaber","Fei Wang","Mohammad Hassan Ameri","Donghang Lu","Alexander Seto","Benjamin Delaware","Roopsha Samanta","Aniket Kate","Christina Garman","Jeremiah Blocki","Pierre-David Letourneau","Benoit Meister","Jonathan Springer","Tiark Rompf","Milind Kulkarni"],"categories":null,"content":"","date":1633046400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1633046400,"objectID":"4de587021619f26c2f1081bb3f595d12","permalink":"https://kirshanthans.github.io/publication/gpce2021/","publishdate":"2021-10-01T00:00:00Z","relpermalink":"/publication/gpce2021/","section":"publication","summary":"Cryptographic techniques have the potential to enable distrusting parties to collaborate in fundamentally new ways, but their practical implementation poses numerous challenges. An important class of such cryptographic techniques is known as Secure Multi-Party Computation (MPC). Developing Secure MPC applications in realistic scenarios requires extensive knowledge spanning multiple areas of cryptography and systems. And while the steps to arrive at a solution for a particular application are often straightforward, it remains difficult to make the implementation efficient, and tedious to apply those same steps to a slightly different application from scratch. Hence, it is an important problem to design platforms for implementing Secure MPC applications with minimum effort and using techniques accessible to non-experts in cryptography. In this paper, we present the HACCLE (High Assurance Compositional Cryptography: Languages and Environments) toolchain, specifically targeted to MPC applications. HACCLE contains an embedded domain-specific language Harpoon, for software developers without cryptographic expertise to write MPC-based programs, and uses Lightweight Modular Staging (LMS) for code generation. Harpoon programs are compiled into acyclic circuits represented in HACCLE’s Intermediate Representation (HIR) that serves as an abstraction over different cryptographic protocols such as secret sharing, homomorphic encryption, or garbled circuits. Implementations of different cryptographic protocols serve as different backends of our toolchain. The extensible design of HIR allows cryptographic experts to plug in new primitives and protocols to realize computation. And the use of standard metaprogramming techniques lowers the development effort significantly. Harpoon programs are compiled into acyclic circuits represented in HACCLE’s Intermediate Representation (HIR) that serves as an abstraction over different cryptographic protocols such as secret sharing, homomorphic encryption, or garbled circuits. Implementations of different cryptographic protocols serve as different backends of our toolchain. The extensible design of HIR allows cryptographic experts to plug in new primitives and protocols to realize computation. And the use of standard metaprogramming techniques lowers the development effort significantly. We have implemented Harpoon and HACCLE, and used them to program interesting applications (e.g., secure auction) and key computation components of Secure MPC applications (e.g., matrix-vector multiplication and merge sort). We show that the performance is improved by using our optimization strategies and heuristics.","tags":[],"title":"HACCLE: Metaprogramming for Secure Multi-Party Computation","type":"publication"},{"authors":["Kirshanthan Sundararajah","Milind Kulkarni"],"categories":null,"content":"","date":1559952000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1559952000,"objectID":"cbf191f5ab488359c810481c409f605e","permalink":"https://kirshanthans.github.io/publication/pldi2019a/","publishdate":"2019-06-08T00:00:00Z","relpermalink":"/publication/pldi2019a/","section":"publication","summary":"Scheduling transformations reorder a program’s operations to improve locality and/or parallelism. The polyhedral model is a general framework for composing and applying instance-wise scheduling transformations for loop-based programs, but there is no analogous framework for recursive programs. This paper presents an approach for composing and applying scheduling transformations—like inlining, interchange, and code motion—to nested recursive programs. This paper describes the phases of the approach—representing dynamic instances, composing and applying transformations, reasoning about correctness—and shows that these techniques can verify the soundness of composed transformations.","tags":[],"title":"Composable, Sound Transformations of Nested Recursion and Loops","type":"publication"},{"authors":["Laith Sakka","Kirshanthan Sundararajah","Ryan R Newton","Milind Kulkarni"],"categories":null,"content":"","date":1559952000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1559952000,"objectID":"69d2a83692433eab04d4dcb4cd9fc2d5","permalink":"https://kirshanthans.github.io/publication/pldi2019b/","publishdate":"2019-06-08T00:00:00Z","relpermalink":"/publication/pldi2019b/","section":"publication","summary":"Applications in many domains are based on a series of traversals of tree structures, and fusing these traversals together to reduce the total number of passes over the tree is a common, important optimization technique. In applications such as compilers and render trees, these trees are heterogeneous: different nodes of the tree have different types. Unfortunately, prior work for fusing traversals falls short in different ways: they do not handle heterogeneity; they require using domain-specific languages to express an application; they rely on the programmer to aver that fusing traversals is safe, without any soundness guarantee; or they can only perform coarse-grain fusion, leading to missed fusion opportunities. This paper addresses these shortcomings to build a framework for fusing traversals of heterogeneous trees that is automatic, sound, and fine-grained. We show across several case studies that our approach is able to allow programmers to write simple, intuitive traversals, and then automatically fuse them to substantially improve performance.","tags":[],"title":"Sound, Fine-grained Traversal Fusion for Heterogeneous Trees","type":"publication"},{"authors":["Nikhil Hegde","Jianqiao Liu","Kirshanthan Sundararajah","Milind Kulkarni"],"categories":null,"content":"","date":1507766400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1507766400,"objectID":"c9e21e19fc2fd01c957f94445dc03d58","permalink":"https://kirshanthans.github.io/publication/ispass2017/","publishdate":"2017-10-12T00:00:00Z","relpermalink":"/publication/ispass2017/","section":"publication","summary":"An interesting class of irregular algorithms is tree traversal algorithms, which repeatedly traverse various trees to perform efficient computations. Tree traversal algorithms form the algorithmic kernels in an important set of applications in scientific computing, computer graphics, bioinformatics, and data mining, etc. There has been increasing interest in understanding tree traversal algorithms, optimizing them, and applying them in a wide variety of settings. Crucially, while there are many possible optimizations for tree traversal algorithms, which optimizations apply to which algorithms is dependent on algorithmic characteristics. In this work, we present a suite of tree traversal kernels, drawn from diverse domains, called Treelogy, to explore the connection between tree traversal algorithms and state-of-the-art optimizations. We characterize these algorithms by developing an ontology based on their structural properties. The attributes extracted through our ontology, for a given traversal kernel, can aid in quick analysis of the suitability of platform- and application-specific as well as independent optimizations. We provide reference implementations of these kernels for three platforms: shared memory multicores, distributed memory systems, and GPUs, and evaluate their scalability.","tags":[],"title":"Treelogy: A Benchmark Suite for Tree Traversals","type":"publication"},{"authors":["Laith Sakka","Kirshanthan Sundararajah","Milind Kulkarni"],"categories":null,"content":"","date":1492992000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1492992000,"objectID":"4917766377e94c9f1ede8e6d10a032cc","permalink":"https://kirshanthans.github.io/publication/oopsla2017/","publishdate":"2017-04-24T00:00:00Z","relpermalink":"/publication/oopsla2017/","section":"publication","summary":"Series of traversals of tree structures arise in numerous contexts: abstract syntax tree traversals in compiler passes, rendering traversals of the DOM in web browsers, kd-tree traversals in computational simulation codes. In each of these settings, a tree is traversed multiple times to compute various values and modify various portions of the tree. While it is relatively easy to write these traversals as separate small updates to the tree, for efficiency reasons, traversals are often manually fused to reduce the number of times that each portion of the tree is traversed: by performing multiple operations on the tree simultaneously, each node of the tree can be visited fewer times, increasing opportunities for optimization and decreasing cache pressure and other overheads. This fusion process is often done manually, requiring careful understanding of how each of traversals of the tree interact. This paper presents an automatic approach to traversal fusion: tree traversals can be written independently, and then our framework analyzes the dependences between the traversals to determine how they can be fused to reduce the number of visits to each node in the tree. A critical aspect of our framework is that it exploits two opportunities to increase the amount of fusion: i) it automatically integrates code motion, and ii) it supports partial fusion, where portions of one traversal can be fused with another, allowing for a reduction in node visits without requiring that two traversals be fully fused. We implement our framework in Clang, and show across several case studies that we can successfully fuse complex tree traversals, reducing the overall number of traversals and substantially improving locality and performance.","tags":[],"title":"TreeFuser: A Framework for Analyzing and Fusing General Recursive Tree Traversals","type":"publication"},{"authors":["Kirshanthan Sundararajah","Laith Sakka","Milind Kulkarni"],"categories":null,"content":"","date":1491264000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1491264000,"objectID":"f94ab052c05b147ac9d42dc366e0f54a","permalink":"https://kirshanthans.github.io/publication/asplos2017/","publishdate":"2017-04-04T00:00:00Z","relpermalink":"/publication/asplos2017/","section":"publication","summary":"There has been a significant amount of effort invested in designing scheduling transformations such as loop tiling and loop fusion that rearrange the execution of dynamic instances of loop nests to place operations that access the same data close together temporally. In recent years, there has been interest in designing similar transformations that operate on recursive programs, but until now these transformations have only considered simple scenarios: multiple recursions to be fused, or a recursion nested inside a simple loop. This paper develops the first set of scheduling transformations for nested recursions: recursive methods that call other recursive methods. These are the recursive analog to nested loops. We present a transformation called recursion twisting that automatically improves locality at all levels of the memory hierarchy, and show that this transformation can yield substantial performance improvements across several benchmarks that exhibit nested recursion.","tags":[],"title":"Locality Transformations for Nested Recursive Iteration Spaces","type":"publication"},{"authors":["Kirshanthan Sundararajah","Sanath Jayasena"],"categories":null,"content":"","date":1459468800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1459468800,"objectID":"d8cb58c2636aa328d2998c12dc608e09","permalink":"https://kirshanthans.github.io/publication/mercon2016/","publishdate":"2016-04-01T00:00:00Z","relpermalink":"/publication/mercon2016/","section":"publication","summary":"In a program, not all the bits of a variable are always used during execution. Identifying the minimum number of bits necessary to represent a variable in a program can potentially provide optimization opportunities. Providing the knowledge of bitwidths to a compilation and execution framework will be advantageous if it could use that information to optimize the execution of the program, for instance, being able to select instructions for SIMD vectorization. This paper introduces a framework to exploit the potential vectorizations hidden in a program which is not exposed during static compilation time. Our framework unlocks instruction level data parallelism by using the bitwidths of array like variables that depend on runtime input. Our framework shows a maximum achievable performance gain of 37% and a mean achievable performance gain of 11% against the ICC compiler on our micro benchmark suite.","tags":[],"title":"Model-based Input-adaptive Vectorization","type":"publication"},{"authors":["Kirshanthan Sundararajah","Lajanugen Logeswaran","Nisal Panagoda","Lakshitha Prabath Wijesinghe","Varuna De Silva","Ajith Pasqual"],"categories":null,"content":"","date":1417392000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1417392000,"objectID":"2f778043c25b612fb5dfc2ffb60e8b74","permalink":"https://kirshanthans.github.io/publication/isvc2014/","publishdate":"2014-12-01T00:00:00Z","relpermalink":"/publication/isvc2014/","section":"publication","summary":"Multi-view video has gained widespread popularity in the recent years. 3DTV, surveillance, immersive teleconferencing and free view-point television are few notable applications of multi-view video. Excessive storage and transmission bandwidth requirements are the major challenges faced by the industry in facilitating multi-view video applications. This paper presents efficient tools for coding of multi-view video based on the state of the art single view video coding standard H.265/HEVC (High Efficiency Video Coding). Our approach employs the LDI (Layered Depth Image) representation technique which is capable of compactly representing 3D scene content. We propose techniques and algorithms for LDI construction, view synthesis, efficient coding of LDI layers and associated auxiliary information. Subjective assessments indicate that our approach offers more than 50% reduction in bitrate compared to HEVC simulcast for the same subjective quality under practical operating bitrates.","tags":[],"title":"Layered Depth Image Based HEVC Multi-view Codec","type":"publication"}]